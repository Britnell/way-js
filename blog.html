<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/x-icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + TS</title>
    <link rel="stylesheet" href="/pages/style.css" />
    <script src="/way-inline.js"></script>
    <script type="module" src="src/way.min.js"></script>
    <script type="module" src="pages/blog.ts"></script>
  </head>

  <body class="content-grid">
    <header class="flex gap-4 py-2">
      <a href="/way-js/" class="mr-auto">Way js</a>
      <a href="/way-js/" class="underline">home</a>
      <a href="/way-js/blog" class="">blog</a>
      <a href="/way-js/demo" class="underline">demos</a>
      <a
        href="https://github.com/Britnell/way-js"
        class="underline"
        target="_blank"
        >git</a
      >
      <a
        href="https://www.npmjs.com/package/wayy"
        class="underline"
        target="_blank"
        >npm</a
      >
    </header>

    <h1 class="text-3xl font-bold my-10">Blog</h1>

    <aside
      x-comp="menu"
      class="hidden lg:block fixed left-0 top-0 bottom-0 w-[200px] px-2 py-4 bg-slate-900"
    >
      <h2 class="font-bold mb-4">Posts</h2>
      <ul>
        <li><a class="hover:underline" href="#01"># v0.1.0</a></li>
        <li><a class="hover:underline" href="#jsx"># JSX was a mistake</a></li>
        <li><a class="hover:underline" href="#why"># WHYYYY</a></li>
      </ul>
    </aside>

    <script>
      way.comp("menu", ({ el }) => {
        console.log("menu inline comp", el);
      });
    </script>
    <article id="01" x-comp="post">
      <div class="x flex justify-between items-center mb-3">
        <h2>
          <a href="#01" class="hover:underline">#</a>
          v0.1.0
        </h2>
        <p class="x text-sm text-slate-300">15.10.25</p>
      </div>
      <p>
        v0! - really this is the first botched together version, I'm curious
        about feedback. It's kind of a combination of all the best things I like
        about alpine, vue, solid etc. <br />
        Seeing what is possible with using minimal libs and as much of browser
        features as possible. Just trying things out, more concerned with how
        the framework looks than the performance for now. Plenty optimisation to
        be done of different directives.
        <br />
        Also trying to integrate forms into the framework but maybe that should
        be a separate module for when its not needed. Same thing with extra
        turbo lib for MPAs.
        <br />
        Still fiddling with how signals are used in markup, currently need to
        use signal.value in dynamic directives etc, but looking to see if that
        can be simplified.
      </p>
    </article>

    <article id="jsx">
      <div class="x flex justify-between items-center mb-3">
        <h2>
          <a href="#jsx" class="hover:underline">#</a>
          JSX was a mistake
        </h2>
        <p class="x text-sm text-slate-300">15.10.25</p>
      </div>
      <p>
        I don't think you need to be a web performance puritan to see the
        benefits of less js & leaner apps.
        <br />
        <br />
        And building this im really not sure why we NEEDED jsx in the first
        place. A new language, that needs to be compiled in an extra step,
        meaning our frameworks don't work vanilla in the browser, and then
        instead of sending a &lt;div class="big"> to the server were now sending
        document.createElement('div').class='big' etc. Meaning we're sending
        loads of extra js, which should be just our code, to transfer what
        should be html.
      </p>
      <p>
        And then came next.js, which would PRE-RENDER your jsx into static html,
        which can look pretty while all the js loads, but its just a big loading
        screen to be replaced by the render output, which means we are sending
        everything TWICE. the &lt;div> AND the jsx document.createElement ...
        All the while leading to the most pointless error of all, the HYDRATION
        ERROR, forcing you to move logic into useEffect() yada yada...
        <br />
        The javascript on a web page (or app) should only be used to describe
        the logic, the shape should be in html... <br />
      </p>
      <!-- Because in truth, half the time we are just changing classes on elements to hide and show things. -->
      <p>
        But then look at vue, it looks more like html than jsx magic, &lt;div
        v-if="show" :class="{'big': big}">, and using &lt;template> elements.
        But jsx seems like pure overhead to me, why can't our framework tie in
        directly with actual html? Work with the dom, and the actual elements.
        And this also means we can use all other vanilla js libraries and web
        components.
        <br />
        'Way' is

        <span class="block my-4 text-center font-bold text-xl">
          essentially just vue without the jsx
        </span>

        But loose the jsx, and we can still have nice things! We have the
        ability for components in html with web-components, and sure they don't
        have reactivity, but we have signals now. It's all already there. I'm
        surprised how easy and quick this was, just had to put all these
        existing pieces together in the right way.
        <br />
        Still of course there is plenty to do still
      </p>
    </article>

    <article id="why">
      <div class="x flex justify-between items-center mb-3">
        <h2>
          <a href="#why" class="hover:underline">#</a>
          WHYYYY
        </h2>
        <p class="x text-sm text-slate-300">15.10.25</p>
      </div>

      <p>
        WHYYY another framework you ask? Well I might argue if this even counts
        a js framework, but anyway, our js frameworks are so bloated, we need to
        get back closer to html, web standards and browser api - as such, I LOVE
        ALPINE.
      </p>

      <h3>Alpine.js</h3>
      <p>
        Way.js is obviously just alpine with components. that is 100% what this
        is.
        <br />
        <br />
        I love the concept of alpine, server render normal html, and the
        framework interactivity is just sprinkled in with html attributes. i
        think thats beautifully simple, and obviously super fast and efficient.
        <br />
        But in reality, we just do a lot of things on the client now, sadly not
        every company will just switch to htmx overnight. So we have some logic
        to implement client side. But build any larger logic and doing
        EVERYTHING in html attributes x-data="{...}" will get cramped. So in
        reality you will always use `Alpine.data('counter',()=>({ x: 123}))`.
      </p>
      <p>
        Which is great, this is a beautiful way to work to me. But let things
        get a big bigger, and there is no easy way for re-usable logic (someone
        will correct me on this). For all the flaws of React, its so nice
        building and thinking in components, let me put the logic and markup for
        one part in a re-usable piece.
      </p>
      <h3>Components</h3>
      <p>
        and YES, i know thats not what alpine is intended for, i read somewhere
        that components were intentionally not added as this was supposed to be
        done through server-side templating. But its 2025 and here we are. I
        came across some alpine extensions for components (probably
        <a href="https://github.com/niconoclaste/alpinejs-web-components">
          this one</a
        >), but that was really just templating, and without a good way to pass
        in props for reusable logic it just wasn't that useful. So i tried
        making this work by writing my own web-components and alpine-extension,
        but I just couldn't get it to work. (I'd love for someone to build this
        for alpine).
      </p>
      <h3>Rebuild</h3>
      <p>
        So here we are, i thought I'd rebuild alpine with signals and
        web-components, in perfect harmony. because fine-grained reactivity is
        perfect for these specific dom updates, and see where it goes. And I'm
        surprisignly happy with the result. I think all these pieces fit
        together really well and the result is small but surprisignly powerful.
        <br />
        I also like the idea of building the NEXT framework on top of all the
        powerful new APIs coming to browsers, with View Transitions, native
        signals etc.
      </p>

      <div class="spa-diag">
        <div class="flex justify-between px-10">
          <span class="mark">alpine</span>
          <span class="mark">react</span>
        </div>
        <div class="line" aria-label="x axis"></div>
        <div class="flex justify-between px-12">
          <span class="">MPA</span>
          <span class="">SPA</span>
        </div>
      </div>

      <h3>SPAc or MPA</h3>
      <p>
        So between a full SSR + alpine and a react SPA I think there is space to
        fill in this spectrum (yes similar area to livewire i guess), for when
        we need something more complex and composable, yet don't want to have to
        reach for a full js framework. Everything is still just html, so server
        render everything and sprinkle in an SPA where you need one.
      </p>
    </article>

    <style>
      [x-load] {
        display: none;
      }
    </style>
  </body>
</html>
